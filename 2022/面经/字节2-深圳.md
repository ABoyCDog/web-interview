+ 自我介绍
+ 项目业务详情
+ 做的前端优化
    - 图片优化
    - 首屏渲染优化
+ 做的一些工程化的事情
    - 监控
    - 埋点

+ js的原型理解（关注原型尽头是什么 -- Object.prototype）
    - https://blog.csdn.net/qq_29055201/article/details/91042097
+ ES5的几种继承方式的异同（原型链继承、借用构造函数继承、组合继承、寄生式组合继承）
+ setTimeout替代setInterval的方案具体细节
+ 事件循环中宏任务与微任务优先级并非绝对的
    - 浏览器为了能够使得JS内部(macro)task与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染
    - 在某一个宏任务(macrotask)执行完后，就会将在它执行期间产生的所有微任务(microtask)都执行完毕（在渲染前）
    1. 执行一个宏任务（栈中没有就从事件队列中获取）
    2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
    3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
    4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
    5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
+ 

算法
+ hook版本的防抖函数
+ 扁平数据变为树状数据结构