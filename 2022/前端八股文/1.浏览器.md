# 浏览器

> 加强浏览器加载、渲染、缓存机制的理解与运用

> 深入理解http和websocket等各种协议

### 1. 浏览器跨域问题
### 2. 浏览器渲染机制
### 3. 浏览器事件循环
### 4. 浏览器重排重绘
### 5. 浏览器垃圾回收机制
+ 垃圾回收：GC（Garbage Collect）
+ V8采用传统的 mark-and-sweep 算法来进行垃圾回收GC，采用增量标记法：不是遍历整个堆栈，而是尝试标记每个可能的对象，它只是遍历堆的一部分，然后恢复正常运行。
+ 分代式垃圾回收机制：
    - 根据对象存活时间进行分类为 新生代(new_space) 和 老生代(old_space)
    - 新生代一般指新创建的对象或者经过一轮回收的对象。
        + 新生代中会分为两个空间，from和to，to一般是闲置的，当from空间满时会执行Scavenge算法进行垃圾回收。当执行垃圾回收算法时应用逻辑会停止，等垃圾回收机制结束后再继续执行。算法分三步：
            - （1）首先检查from空间的存活对象，如果对象存活则判断是否满足晋升老生代的条件（两个条件如下），满足则晋升为老生代，不满足则移动至To空间。
                + 条件1: 判断对象是否经历过一次scanvenge回收。如经历过，则将对象从From空间复制到老生代中；若没有经历，则复制到To空间中。
                + 条件2:第二个是To空间的内存使用占比是否超过限制。对象从From复制到To空间时，若To空间使用超过25%，则对象直接晋升到老生代。设置25%是因为算法结束后，两个空间会交换位置，如果To空间内存过小会影响内存分配。
            - （2）如果对象不存活，则释放对象的空间。
            - （3）最后将From空间和To空间角色进行交换。
    - 老生代指经历过多次垃圾回收的对象
        + 老生代采用了标记清除法(mark-sweep)和标记压缩法(mark-compact).
        + 标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。
        + 由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。
        + 由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。
### 6. 内存泄漏
+ 其实浏览器和大部分的前端框架在底层已经帮助我们处理了常见的内存泄漏，但我们也应该了解下如何判断是否内存泄漏以及应该如何预防内存泄漏。
+ 如何检查内存泄漏？
    - 打开chrome浏览器查看内存占用（performance实时查看内存占用情况）：
        1. 开发者工具
        2. performance面板
        3. 将默认勾选的screenshots改为memory
        4. 点击start profiling and reload page
        5. 页面开始刷新并同时录制，等待页面加载完成后，点击stop，面板上就会显示内存占用情况
        6. 如果内存占用稳定说明无泄漏，反之则是泄漏了（查看 JS Heap size 和 DOM Nodes的数量，如果持续升高，则表明内存泄漏）
+ 产生内存泄漏的几种场景：
    1. 意外的全局变量
        - 函数中意外定义了全局变量，每次执行函数都会生成该变量，且不会随着函数结束运行而释放
    2. 未清除的定时器
        - 定时器没有清除，它内部引用的变量不会被释放
    3. 脱离Dom元素的引用
        - 一个dom容器删除后，变量未设置为null，其内部的dom元素则不会释放。通过memory快照，可以看到detached的dom元素即为脱离dom的元素引用。
    4. 闭包引起的内存泄漏
    5. 持续绑定的事件
        - 函数中addEventListener绑定事件，函数多次执行，绑定便会产生多次，造成内存泄漏。
    6. Map对象中的key无法被垃圾回收机制回收，改为使用weakMap
+ 如何避免内存泄漏：
    - 减少创建全局变量，减少使用闭包，及时清除定时器，及时清除dom引用，弱引用（weakmap）等

### 7. JS运行机制
https://mp.weixin.qq.com/s/_EJoEGqe6Vk33jeRLdFd_g

#### 进程与线程
+ 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
+ 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
+ 不同进程之间也可以通信，不过代价较大
+ 现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）

