# 浏览器

> 加强浏览器加载、渲染、缓存机制的理解与运用

> 深入理解http和websocket等各种协议

## 1. 浏览器跨域问题
## 2. 浏览器渲染机制
## 3. 浏览器事件循环
## 4. 浏览器重排重绘
## 5. 浏览器垃圾回收机制
+ 垃圾回收：GC（Garbage Collect）
+ V8采用传统的 mark-and-sweep 算法来进行垃圾回收GC，采用增量标记法：不是遍历整个堆栈，而是尝试标记每个可能的对象，它只是遍历堆的一部分，然后恢复正常运行。
+ 分代式垃圾回收机制：
    - 根据对象存活时间进行分类为 新生代(new_space) 和 老生代(old_space)
    - 新生代一般指新创建的对象或者经过一轮回收的对象。
        + 新生代中会分为两个空间，from和to，to一般是闲置的，当from空间满时会执行Scavenge算法进行垃圾回收。当执行垃圾回收算法时应用逻辑会停止，等垃圾回收机制结束后再继续执行。算法分三步：
            - （1）首先检查from空间的存活对象，如果对象存活则判断是否满足晋升老生代的条件（两个条件如下），满足则晋升为老生代，不满足则移动至To空间。
                + 条件1: 判断对象是否经历过一次scanvenge回收。如经历过，则将对象从From空间复制到老生代中；若没有经历，则复制到To空间中。
                + 条件2:第二个是To空间的内存使用占比是否超过限制。对象从From复制到To空间时，若To空间使用超过25%，则对象直接晋升到老生代。设置25%是因为算法结束后，两个空间会交换位置，如果To空间内存过小会影响内存分配。
            - （2）如果对象不存活，则释放对象的空间。
            - （3）最后将From空间和To空间角色进行交换。
    - 老生代指经历过多次垃圾回收的对象
        + 老生代采用了标记清除法(mark-sweep)和标记压缩法(mark-compact).
        + 标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。
        + 由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。
        + 由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。
## 6. 内存泄漏
+ 其实浏览器和大部分的前端框架在底层已经帮助我们处理了常见的内存泄漏，但我们也应该了解下如何判断是否内存泄漏以及应该如何预防内存泄漏。
+ 如何检查内存泄漏？
    - 打开chrome浏览器查看内存占用（performance实时查看内存占用情况）：
        1. 开发者工具
        2. performance面板
        3. 将默认勾选的screenshots改为memory
        4. 点击start profiling and reload page
        5. 页面开始刷新并同时录制，等待页面加载完成后，点击stop，面板上就会显示内存占用情况
        6. 如果内存占用稳定说明无泄漏，反之则是泄漏了（查看 JS Heap size 和 DOM Nodes的数量，如果持续升高，则表明内存泄漏）
+ 产生内存泄漏的几种场景：
    1. 意外的全局变量
        - 函数中意外定义了全局变量，每次执行函数都会生成该变量，且不会随着函数结束运行而释放
    2. 未清除的定时器
        - 定时器没有清除，它内部引用的变量不会被释放
    3. 脱离Dom元素的引用
        - 一个dom容器删除后，变量未设置为null，其内部的dom元素则不会释放。通过memory快照，可以看到detached的dom元素即为脱离dom的元素引用。
    4. 闭包引起的内存泄漏
    5. 持续绑定的事件
        - 函数中addEventListener绑定事件，函数多次执行，绑定便会产生多次，造成内存泄漏。
    6. Map对象中的key无法被垃圾回收机制回收，改为使用weakMap
+ 如何避免内存泄漏：
    - 减少创建全局变量，减少使用闭包，及时清除定时器，及时清除dom引用，弱引用（weakmap）等

## 7. JS运行机制
https://mp.weixin.qq.com/s/_EJoEGqe6Vk33jeRLdFd_g

### 进程与线程
+ 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
+ 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
+ 不同进程之间也可以通信，不过代价较大
+ 现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）
+ 浏览器包含哪些进程：
    - Browser进程：浏览器的主进程（负责协调、主控），只有一个。
        - 负责浏览器界面显示，与用户交互。如前进后退等；
        - 负责各个页面的管理，创建和销毁其他进程；
        - 将render进程得到内存中的bitmap绘制到用户界面上；
        - 网络资源的管理，下载等
    - 第三方插件进程：每种类型的插件对应一个进程，当且仅当插件使用时才会创建
    - GPU进程：用于3D绘制等
    - 浏览器渲染进程：浏览器内核，render进程，内部是多线程的，默认每个tab页面是一个进程，互不影响，主要作用为页面渲染、脚本执行、事件处理等。
        1. GUI渲染线程：
            + 负责渲染浏览器界面，解析HTML、CSS，构建DOM树和RenderObject树，布局和重绘；
            + 当界面需要重绘（Repaint）或由于某种操作引发回流（reflow）时，该线程就会执行；
            + 注意，GUI线程与JS引擎线程是互斥的，当JS引擎线程执行程序时，GUI线程就会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行；
        2. JS引擎线程：
            + JS内核，负责执行JS脚本程序（例如V8引擎）
            + JS引擎线程负责解析JS代码，运行程序代码；
            + JS引擎一直等待队列中任务的到来，然后再加以处理，每个tab页面（render进程）中无论何时都只有一个JS线程在运行JS程序
            + 同样，JS引擎线程与GUI渲染线程互斥，当JS执行时间过长，就会造成页面渲染不连贯导致页面加载阻塞
        3. 事件触发线程：
            + 归属于浏览器而不是JS引擎，用于控制事件循环（可以理解为JS自己忙不过来，需要浏览器另开线程来协助）
            + 当JS引擎执行代码块如setTimeout时（也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等），会讲对应任务添加到事件线程中去
            + 当对应事件符合触发的条件时，该线程会把对应的线程添加至待处理队列的队尾，等待JS引擎处理
            + 注意，由于JS是单线程的关系，这些待处理队列中的事件只有排队等待JS引擎处理（当JS引擎空闲时才回去处理）
        4. 定时触发器线程：
            + 传说的setInterval和setTimeout所在的线程
            + 浏览器的定时计数器并不是由JS引擎计数的，因为JS是单线程 如果处于线程阻塞状态就会影响计数的准确性
            + 因此通过单线程来计时并来触发定时（计时完成后添加到时间队列中，等待JS引擎空闲后执行）
            + 注意W3C在HTML标准中规定，setTimeout中低于4ms的时间间隔算作4ms，即setTimeout最小时延为4ms
        5. 异步http请求线程：
            + XMLHttpRequest在连接后是通过浏览器新开一个线程发起请求
            + 在监测到状态变更时，如果设置有回调函数，异步线程就会产生状态变更事件，将这个回调事件再放入事件队列，等待JS引擎执行
        + ![image](https://mmbiz.qpic.cn/mmbiz_png/mshqAkialV7HrUYsWYxnQUcPjq2X1EPoibqFeCvyIBCPib2mFpu3icico8YdY4dRIibtEkGXC6EDGMrWg1TGzu7AEkUw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

+ Browser进程与浏览器内核（Render进程）的通信
    - 谈谈browser进程（控制进程）和内核如何通信的？
        + Browser进程收到用户请求，首先需要获取页面内容（比如通过网络下载资源）。随后将该任务通过renderHost接口传递给render进程
        + render进程的render接口收到消息，简单解释后，交给渲染线程，然后开始渲染
            - 渲染线程收到请求，加载网页并渲染网页，这其中可能需要browser进程获取资源和GPU进程帮助渲染
            - 当然可能会有JS线程操作DOM（可能造成回流并重绘）
            - 最后Render进程将结果传递给Browser进程
        + Browser进程接收到结果并将结果绘制出来
    - Browser进程、Render进程、GPU进程，这三个都是相互关联的，且都是双向的
    - ![image](https://mmbiz.qpic.cn/mmbiz_png/mshqAkialV7HrUYsWYxnQUcPjq2X1EPoibnNaTSA58ic7icH93Uib927SST4ZVLn8TPsXKmGzjgL6xO96jaMNbApMFA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

+ 梳理浏览器内核中线程之间的关系
    - GUI渲染线程与JS引擎线程互斥
        > 由于JS是可操作DOM的，如果在修改元素属性的同时渲染界面，那么渲染线程前后获取的元素数据可能就不一致了。所以为了防止渲染出现不可预期的结果，浏览器便设置为两个线程互斥，当JS引擎执行时GUI线程就会被挂起，GUI更新会被保存到一个队列中；当JS引擎线程空闲时队列中的GUI线程任务立即被执行
    - JS阻塞页面加载
        > 由于JS引擎线程与GUI渲染线程互斥，JS执行时间过长就会阻塞页面加载，所以要尽量避免JS执行时间过长导致出现页面渲染不连贯问题。
    - WebWorker 时JS的多线程？
        > webworker是HTML5支持的新特性，MDN官方解释是：Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件。这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window。因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误。
        - 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，且不能操作DOM）
        - JS引擎线程与worker子线程之间通过特定的方式进行通信（postMessage API，需要通过序列化对象来实现与线程交互特定的数据）
        > 所以，如果有特别耗时的工作，申请一个worker子线程，这样里面不管如何翻天覆地，都不影响JS引擎主线程，只待计算出结果后，将结果通信给主线程即可。
        - 而且需要注意的是，JS引擎是单线程的本质还是没变，知识可以理解为浏览器给JS引擎开了一个处理复杂任务的外挂。
    - webworker 和 sharedsharedworker 
        + webworker是只属于某个tab页面的，不会与其他页面的render进程（浏览器内核）共享
            > 所以chrome中每一个tab页就是一个render进程
        + SharedWorker是浏览器中所有页面共享的，不能采用与webworker相同的方式实现，因为不属于某个render进程，而是所有的render进程共享的。
            > 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。
        + 本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程

+ 浏览器渲染流程
    - 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程
    - 浏览器渲染流程开始
    浏览器内核拿到内容之后，渲染大概可以划分成以下几个步骤：
    1. 解析html建立DOM树；
    2. 解析CSS构建render树（将CSS代码解析为树状数据结构，然后结合DOM树合并形成Render渲染树）；
    3. 布局Render树(layout/reflow)，负责各元素位置、尺寸的计算；
    4. 绘制render树（paint），绘制页面像素信息；
    5. 浏览器将各层信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。

    渲染完毕后就是load事件，之后就是JS逻辑处理了。

    ![image](https://mmbiz.qpic.cn/mmbiz_png/mshqAkialV7HrUYsWYxnQUcPjq2X1EPoib1FukrxxPPZoQbssyB2KueUXTEaJe89WH0s1FFyYFxlRI3MofrAYcKw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

+ load事件 与 DOMContentLoaded事件 的先后
    - 上面提到渲染完毕会触发load事件
    - 当DOMontentLoaded事件加载，仅当DOM加载完毕，不包括样式表、图片。（比如有async加载的脚本就不一定完成）
    - 当onLoaded事件触发时，页面上的所有DOM、样式表、脚本、图片都已加载完毕。（渲染完成了）
    - 所以，顺序是 DOMContentLoaded -> load
+ CSS加载是否会阻塞DOM树渲染？
    - 这里说的是头部引入css的情况
    - 我们都知道，css是由单独的下载线程异步下载的。
    - css加载不会阻塞DOM树解析（异步加载时，DOM树照常构建）
    - 但是会阻塞render树渲染（因为render树是需要DOM树与CSS信息的）
    - 这其实也是浏览器的一种优化机制，因为在加载css的时候你可能会修改其下面的DOM节点样式，如果css加载不阻塞render树渲染的话，当css加载完毕，render树可能又要进行回流或重绘，这就造成了没有必要的消耗。所以干脆先把DOM树解析完，把可以做的工作都做了，然后等css加载完毕后，再根据最终的样式来渲染render树，这种做法在性能方面可能也会好一些。






