# 浏览器
### 1. 浏览器跨域问题
### 2. 浏览器渲染机制
### 3. 浏览器事件循环
### 4. 浏览器重排重绘
### 5. 浏览器垃圾回收机制
+ 垃圾回收：GC（Garbage Collect）
+ V8采用传统的 mark-and-sweep 算法来进行垃圾回收GC，采用增量标记法：不是遍历整个堆栈，而是尝试标记每个可能的对象，它只是遍历堆的一部分，然后恢复正常运行。
+ 分代式垃圾回收机制：
    - 根据对象存活时间进行分类为新生代和老生代
    - 新生代一般指新创建的对象或者经过一轮回收的对象。
        - 新生代中会分为两个空间，from和to，to一般是闲置的，当from空间满时会执行Scavenge算法进行垃圾回收。当执行垃圾回收算法时应用逻辑会停止，等垃圾回收机制结束后再继续执行。算法分三步：
            - 首先检查from空间的存活对象
    - 老生代指经历过多次垃圾回收的对象
    - 
### 6. 内存泄漏
+ 其实浏览器和大部分的前端框架在底层已经帮助我们处理了常见的内存泄漏，但我们也应该了解下如何判断是否内存泄漏以及应该如何预防内存泄漏。
+ 如何检查内存泄漏？
    - 打开chrome浏览器查看内存占用（performance实时查看内存占用情况）：
        1. 开发者工具
        2. performance面板
        3. 将默认勾选的screenshots改为memory
        4. 点击start profiling and reload page
        5. 页面开始刷新并同时录制，等待页面加载完成后，点击stop，面板上就会显示内存占用情况
        6. 如果内存占用稳定说明无泄漏，反之则是泄漏了（查看 JS Heap size 和 DOM Nodes的数量，如果持续升高，则表明内存泄漏）
+ 产生内存泄漏的几种场景：
    1. 意外的全局变量
        - 函数中意外定义了全局变量，每次执行函数都会生成该变量，且不会随着函数结束运行而释放
    2. 未清除的定时器
        - 定时器没有清除，它内部引用的变量不会被释放
    3. 脱离Dom元素的引用
        - 一个dom容器删除后，变量未设置为null，其内部的dom元素则不会释放。通过memory快照，可以看到detached的dom元素即为脱离dom的元素引用。
    4. 闭包引起的内存泄漏
    5. 持续绑定的事件
        - 函数中addEventListener绑定事件，函数多次执行，绑定便会产生多次，造成内存泄漏。
    6. Map对象中的key无法被垃圾回收机制回收，改为使用weakMap
+ 如何避免内存泄漏：
    - 减少创建全局变量，减少使用闭包，及时清除定时器，及时清除dom引用，弱引用（weakmap）等