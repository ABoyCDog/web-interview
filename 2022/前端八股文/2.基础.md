# 基础
1. 前端模块化规范
2. TypeScript
3. New操作符的原理
4. 闭包的作用和原理
5. ES5、ES6如何实现继承（JS原型链）
6. JavaScript异步编程
   ## 同步与异步
    在 JS 中，通常代码按顺序从上到下同步执行，但某些特殊场景/操作下需要以异步的方式执行，即将代码划分为至少两部分，先执行一部分代码，在进行耗时操作时将主线程的执行权交出，执行其他代码，待耗时任务完成后以一定规则触发使得另一部分代码被继续执行，主要流程如下图所示。

    ![image](../../2020-2021/images/同步异步.png)

        JS 中常见的异步执行场景：网络请求（Ajax 等）、定时器（SetTimeout 等）、IO 操作（readFile 等）...

        对于 JS 的这些异步场景，有两个重点：

        > 1.得知异步任务何时结束，以便进行后续操作；

        > 2.处理多个异步任务按顺序执行/并发执行的场景；

        在处理 JS 异步场景方法的衍化过程当中，逐步出现了几种方式：

        - 回调函数

        - 事件监听

        - 发布订阅

        - Promise

        - Generator/yield

        - Async/await

    ## 回调函数

    JS 中最常见的处理异步问题的方法，将任务结束时要做的事（或者说必须拿到异步任务的结果才能进行的操作）包装成函数作为参数传递给异步操作，待异步操作结束后执行函数，称之为“回调”函数。如 SetTimeout 函数就接受一个函数参数作为回调函数，在指定延迟时间后执行该回调函数：

    ```js
    setTimeout(function(){//延迟100ms后执行“代码块”；延迟即视为异步操作，代码块则是异步操作结束后的“回调函数”；
        //代码块
    }，100);
    ```

    > 回调函数的异步方法简单易理解，但不利于代码维护，尤其在多个异步任务继发执行使得回调函数嵌套的情况下，代码耦合度高不利于代码的阅读和维护，且每个任务只能指定一个回调函数。此外它不能使用 try catch 捕获错误，不能直接 return。

    > > 虽然回调函数这种方式问题很多，但是不可否认的是在 ES6 之前，他就是处理异步问题普遍较好的方式，而且后面很多方式仍然基于回调函数。

    ## 事件监听

    JS 中关于 DOM 操作的一系列监听事件也属于异步方法，如监听各种元素的 onclick、onload 等方法。只有当监听元素对应的事件被发生时对应的代码才会被执行。

    回调函数与事件监听的区别：

    - 回调函数多是一对一的关系，事件监听可以是多对一。

    - 运行异步函数，在一个不确定的时间段之后运行回调函数；不确定何时触发事件，但是触发事件同步响应事件的回调。

    - 事件监听相对于回调函数，可配置的监听（可增可减）关系减少了耦合性。

    - 不过事件监听也存在问题：

    - 多对多的监听组成了一个复杂的事件网络，单个节点通常监听了多个事件，维护成本很大。

    - 多个异步事件仍然还是回调的形式。

    ## 发布订阅

    和事件监听非常类似的是发布/订阅者模式，在事件监听的基础上，假定存在一个 " 消息中心 "，某个任务执行完成，就向消息中心 " 发布 "（publish）一个消息，其他任务可以向消息中心 " 订阅 "（subscribe）这个消息，从而知道什么时候自己可以开始执行。（直观产品就是微信的公众号模式）

        发布订阅模式在事件监听的基础上增加消息中心的概念，使得多个监听事件的运转流程和消息传递更加有序。但与事件监听相同的是发布订阅者模式也是“事件驱动”型，无法预知到事件何时发生/发布。

    ## Promise

    Promise 的三种状态：pending（进行中），fulfilled（已成功），rejected（已失败），其状态只能从进行中到成功或者是失败，不可逆。而当 Promise 成功/失败/发生错误时可以调用不同的回调函数来处理不同的情况。当状态定型后称为 resolved(已定型)，为了方便表述，后续所有 resolved 统一只指 fulfilled 状态，不包含 rejected 状态。基本使用方法如下：

    ```js
    let promise1 = new Promise((resolve, reject) => {//传入resolve和reject两个函数(自带，名字也随意)来改变Promise的状态
    //一顿操作
    if(/*异步操作成功*/){
        resolve('success'); //调用resolve函数使Promise状态从pengding=>fulfilled,reject则相反；
    }else{
        reject('reject');
    }
    //还可以操作，promise状态变化后仍会继续执行代码，但原则上不应该，因此可以用return resolve();的方式避免该情况；
    });
    promise1.then(//then方法是在Promise结束(成功/失败)后进行调用，可以传入两个回调函数作为参数分别对应成功/失败的状态；
    value => {//回调函数的参数(此为value)则是Promise状态转换时传递出的信息，resolve("success")中的“success”；
        console.log(value);
    },
    reason => {//then方法的第二个回调函数为可选；
        console.log(reason);//reject
    }
    )
    ```
