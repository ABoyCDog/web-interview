# 浏览器垃圾回收机制
+ 垃圾回收：GC（Garbage Collect）
+ V8采用传统的 mark-and-sweep 算法来进行垃圾回收GC，采用增量标记法：不是遍历整个堆栈，而是尝试标记每个可能的对象，它只是遍历堆的一部分，然后恢复正常运行。
+ 分代式垃圾回收机制：
    - 根据对象存活时间进行分类为 新生代(new_space) 和 老生代(old_space)
    - 新生代一般指新创建的对象或者经过一轮回收的对象。
        + 新生代中会分为两个空间，from和to，to一般是闲置的，当from空间满时会执行Scavenge算法进行垃圾回收。当执行垃圾回收算法时应用逻辑会停止，等垃圾回收机制结束后再继续执行。算法分三步：
            - （1）首先检查from空间的存活对象，如果对象存活则判断是否满足晋升老生代的条件（两个条件如下），满足则晋升为老生代，不满足则移动至To空间。
                + 条件1: 判断对象是否经历过一次scanvenge回收。如经历过，则将对象从From空间复制到老生代中；若没有经历，则复制到To空间中。
                + 条件2:第二个是To空间的内存使用占比是否超过限制。对象从From复制到To空间时，若To空间使用超过25%，则对象直接晋升到老生代。设置25%是因为算法结束后，两个空间会交换位置，如果To空间内存过小会影响内存分配。
            - （2）如果对象不存活，则释放对象的空间。
            - （3）最后将From空间和To空间角色进行交换。
    - 老生代指经历过多次垃圾回收的对象
        + 老生代采用了标记清除法(mark-sweep)和标记压缩法(mark-compact).
        + 标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。
        + 由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。
        + 由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。




+ 