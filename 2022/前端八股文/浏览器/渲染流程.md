# 浏览器渲染流程
- 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程
- 浏览器渲染流程开始
浏览器内核拿到内容之后，渲染大概可以划分成以下几个步骤：
1. 解析html建立DOM树；
2. 解析CSS构建render树（将CSS代码解析为树状数据结构，然后结合DOM树合并形成Render渲染树）；
3. 布局Render树(layout/reflow)，负责各元素位置、尺寸的计算；
4. 绘制render树（paint），绘制页面像素信息；
5. 浏览器将各层信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。

渲染完毕后就是load事件，之后就是JS逻辑处理了。

![image](https://mmbiz.qpic.cn/mmbiz_png/mshqAkialV7HrUYsWYxnQUcPjq2X1EPoib1FukrxxPPZoQbssyB2KueUXTEaJe89WH0s1FFyYFxlRI3MofrAYcKw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

+ load事件 与 DOMContentLoaded事件 的先后
    - 上面提到渲染完毕会触发load事件
    - 当DOMontentLoaded事件加载，仅当DOM加载完毕，不包括样式表、图片。（比如有async加载的脚本就不一定完成）
    - 当onLoaded事件触发时，页面上的所有DOM、样式表、脚本、图片都已加载完毕。（渲染完成了）
    - 所以，顺序是 DOMContentLoaded -> load
+ CSS加载是否会阻塞DOM树渲染？
    - 这里说的是头部引入css的情况
    - 我们都知道，css是由单独的下载线程异步下载的。
    - css加载不会阻塞DOM树解析（异步加载时，DOM树照常构建）
    - 但是会阻塞render树渲染（因为render树是需要DOM树与CSS信息的）
    - 这其实也是浏览器的一种优化机制，因为在加载css的时候你可能会修改其下面的DOM节点样式，如果css加载不阻塞render树渲染的话，当css加载完毕，render树可能又要进行回流或重绘，这就造成了没有必要的消耗。所以干脆先把DOM树解析完，把可以做的工作都做了，然后等css加载完毕后，再根据最终的样式来渲染render树，这种做法在性能方面可能也会好一些。
+ 普通图层和复合图层
    - 渲染步骤中提到了composite概念，可以简单理解为浏览器渲染可以简单分为 普通图层 和 复合图层。
    - 首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）；
    - 其次，absolute布局（fixed布局也一样）虽然可以脱离普通文档流，但他仍属于默认复合层；
    - 可以通过 硬件加速 的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合图层里的回流重绘）
    - 可以简单理解为，GPU中各个复合图层是独立绘制的，所以互不影响，这也是为什么某些硬件加速效果一级棒
+ 如何变成复合图层（也就是硬件加速）？
    - 将该元素变为一个复合图层，就是传说中的硬件加速技术
        + 最常用方式就是 translate3d、translatez
        + opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
        + will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）
        + ` video iframe  canvas webgl `等元素
        + 其它，譬如以前的flash插件
    - absolute和硬件加速的区别
        + 可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。所以，就算absolute中信息改变时不会改变普通文档流中render树， 但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）
        + 而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层 （当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）
    - 复合图层的作用？
        + 一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能
        + 但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡
    - 硬件加速时请使用index
        + 使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染
        + 具体的原理是这样的：webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低， 那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的）， 会默认变为复合层渲染，如果处理不当会极大的影响性能
        + 简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意
        + 另外，这个问题可以在这个地址看到重现（原作者分析的挺到位的，直接上链接）：http://web.jobbole.com/83575/