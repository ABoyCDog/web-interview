# 编程
## 1. 手写Promise

## 2. 手写promise.all
+ 要注意几点：
  + 1、先判断参数是否iterator；
  + 2、非promise实例进行Promise.resolve()
  + 3、如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调
  + 4、只要有一个失败，状态就变为 rejected，返回值将直接传递给回调，且返回值也是新的 Promise 对象


```js
    promise.alllll = function(promise) {
        const iterator = Symbol.iterator;
        if(!promise[iterator]) return;
        let count = 0;
        let resolveArr = [];
        return new Promise((resolve, reject) => {
            for(let i = 0; i < promise.length; i++) {
                if(!(promise[i] instanceof Promise)) {
                    promise[i] = Promise.resolve(promise[i]);
                }
                promise[i].then(res => {
                    resolveArr[i] = res;
                    count++;
                    if(count === promise.length) {
                        return resolve(resolveArr);
                    }
                }).catch(err => {
                    return reject(err);
                })
            }
        });
    }
```

## 3. 节流防抖

## 4. 深克隆
+ 有一种简单的深克隆，但是无法覆盖对象中有对象、数组、函数、正则等。即
```js
const deepObj = JSON.parse(JSON.stringfy(obj));
```
+ 

## 5.链式调用-实现lazyMan
```js
    class _LazyMan(name) {
        constructor(name) {
            this.name = name;
            this.queue = [];
            this.queue.push(() => {
                console.log('Hi! This is ' + name + '!');
            });
            setTimeout(() => {
                this.next();
            }, 0)
        }

        eat (arg) {
            this.queue.push(() => {
                console.log('Eat ' + arg + '~');
                this.next();
            })
            return this;
        }

        sleep (time) {
            this.queue.push(() => {
                setTimeout(() => {
                    console.log('Wake up after ' + time + 's!');
                    this.next();
                }, time * 1000);
            });
            return this;
        }

        sleepFirst (time) {
            this.queue.unshift(() => {
                setTimeout(() => {
                    console.log('Wake up after ' + time + 's!');
                    this.next();
                }, time * 1000);
            })
            return this;
        }

        next () {
            let fn = this.queue.shift();
            fn && fn();
        }
    }

    function LazyMan (name) {
        return new _LazyMan(name);
    }

    LazyMan('Hank').eat('Apple').sleep(3).eat('Bananer'); //
    
```

## 6、控制请求并发数，比如发起20个请求，但最大的并发数key为10？
+ 思路：使用队列，队列长度为最大并发数，每有一个请求完成则进行出队列。

## 7、解析URL Params为对象
+ 思路：先将URL匹配的第一个？后面的字符串取出来，将字符串以&分割为数组，然后遍历对每一个元素解码并分割为key和value存至对象，如果只有key没有value则设置为null/undefined。

```js
    function parseParams(url) {
        let paramsObj = {};
        const paramsStr = /.+\?(.+)$/.exec(url)[1]; // 将？后的字符串取出来
        const paramsArr = paramsStr.split('&'); // 以&分割字符串存至数组
        paramsArr.forEach(param => {
            if (/=/.test(param)) { // 处理有value的参数
                let [key, val] = param.split('=');
                val = decodeURIComponent(val); // 解码
                val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字

                if (paramsObj.hasOwnProperty(key)) { // 判断是否已经存在key，存在则concat
                    paramsObj[key] = [].concat(paramsObj[key], val)；
                } else {
                    paramsObj[key] = val;
                }
            } else { // 没有value
                paramsObj[param] = true;
            }
        })

        return paramsObj;
    }
```

## 8、实现模版字符串
```js
    function templateStr(template, data) {
        const reg = /\{\{(\w+)\}\}; // 模板字符串正则
        if (reg.test(template)) {
            const name = reg.exec(template)[1]; // 查找模版第一个模版字符串的字段
            template = template.replace(reg, data[name]); // 将第一个模板字符串渲染
            return templateStr(template, data); // 递归渲染并返回渲染后的结构
        }
        return template; // 如果没有则直接返回
    }
```