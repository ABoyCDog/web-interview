# 编程
## 1. 手写Promise

## 2. 手写promise.all
+ 要注意几点：
  + 1、先判断参数是否iterator；
  + 2、非promise实例进行Promise.resolve()
  + 3、如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调
  + 4、只要有一个失败，状态就变为 rejected，返回值将直接传递给回调，且返回值也是新的 Promise 对象


```js
    promise.alllll = function(promise) {
        const iterator = Symbol.iterator;
        if(!promise[iterator]) return;
        let count = 0;
        let resolveArr = [];
        return new Promise((resolve, reject) => {
            for(let i = 0; i < promise.length; i++) {
                if(!(promise[i] instanceof Promise)) {
                    promise[i] = Promise.resolve(promise[i]);
                }
                promise[i].then(res => {
                    resolveArr[i] = res;
                    count++;
                    if(count === promise.length) {
                        return resolve(resolveArr);
                    }
                }).catch(err => {
                    return reject(err);
                })
            }
        });
    }
```

## 3. 节流防抖

## 4. 深克隆
+ 有一种简单的深克隆，但是无法覆盖对象中有对象、数组、函数、正则等。即
```js
const deepObj = JSON.parse(JSON.stringfy(obj));
```
+ 

## 5.链式调用-实现lazyMan
```js
    class _LazyMan(name) {
        constructor(name) {
            this.name = name;
            this.queue = [];
            this.queue.push(() => {
                console.log('Hi! This is ' + name + '!');
            });
            setTimeout(() => {
                this.next();
            }, 0)
        }

        eat (arg) {
            this.queue.push(() => {
                console.log('Eat ' + arg + '~');
                this.next();
            })
            return this;
        }

        sleep (time) {
            this.queue.push(() => {
                setTimeout(() => {
                    console.log('Wake up after ' + time + 's!');
                    this.next();
                }, time * 1000);
            });
            return this;
        }

        sleepFirst (time) {
            this.queue.unshift(() => {
                setTimeout(() => {
                    console.log('Wake up after ' + time + 's!');
                    this.next();
                }, time * 1000);
            })
            return this;
        }

        next () {
            let fn = this.queue.shift();
            fn && fn();
        }
    }

    function LazyMan (name) {
        return new _LazyMan(name);
    }

    LazyMan('Hank').eat('Apple').sleep(3).eat('Bananer'); //
    
```

## 6、控制请求并发数，比如发起20个请求，但最大的并发数key为10？
+ 思路：使用队列，队列长度为最大并发数，每有一个请求完成则进行出队列。
